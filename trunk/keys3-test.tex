% !TEX program  = pdflatex
\immediate\write18{tex keys3.ins}

\documentclass{article}
\usepackage{keys3,xparse}
\usepackage[parfill]{parskip}

% The document commands for creating keys is very simple. A generic
% one is created to set any modules keys, and one specific to the module 
% used here.
\ExplSyntaxOn
\DeclareDocumentCommand{\SetModuleKeys}{m}{
  \keys_manage:n{
    module~name/.cd:,
    #1}
}

\DeclareDocumentCommand{\SetKeys}{m}{
  \keys_manage:n{#1}
}

\ExplSyntaxOff

\begin{document}

% Each test starts with a short piece of text explaining the property
% being used. Under this, the expected output is given, followed
% if relevant by the text of any error messages expected.

% Test one: Simply creating a key with one argument and then using it.
% Notice that the text length determines the limits of the argument: 
% spaces at either end are ignored. Literal spaces between text are 
% counted, as are those enclosed in braces.
% ----------------------------------------------------------------------
%   You said: `Hello World'
%   You said: ` Hello World '
%   You said: `'
% ----------------------------------------------------------------------
\SetModuleKeys{
  key/.code:n = {You said: `#1'\\},
  key = Hello World ,
  key = { Hello World },
  key 
}

% Test two: Creating a multiple-argument key. Here, the arguments
% given need to be at least as many as those required by the code!
% ----------------------------------------------------------------------
%   You said: `A', `B', `C', D'.
%   You said: `AAA', `BBB', `CCC', ` DDD'.
%   You said: `', `', `', `'.
% ----------------------------------------------------------------------
\SetModuleKeys{
  key/.code:Nn = 4 {You said: `#1', `#2', `#3', `#4'.\\},
  key = ABCD,
  key = {AAA}{BBB} {CCC} { DDD},
  key =,
}

% Test three: The ability to change the key path is available with the
% .cd: property. The following moves from the key root to two separate
% paths, creating keys with the same names.
% ----------------------------------------------------------------------
%   A key in path one
%   A key in path two
%   A key in path two
%   A key in path one
% ----------------------------------------------------------------------
\SetKeys{
  /path one/.cd:,
  key/.code:n = A key in path one\\,
  /path two/.cd:,
  key/.code:n = A key in path two\\,
  /path one/key,
  /path two/key,
  key,
  /path one/.cd:,
  key
}

% Test four: Variants of .code:n and .code:Nn exist which carry out a
% full expansion on code definition. First the :x variant is tested.
% ----------------------------------------------------------------------
%   Temp holds: ABC
%   Temp hold: 123
% ----------------------------------------------------------------------
\newcommand*{\temp}{123}
\SetModuleKeys{
  key one/.code:n = Temp holds: \temp\\,
  key two/.code:x = Temp holds: \temp,
}
\renewcommand*{\temp}{ABC}
\SetModuleKeys{
  key one,
  key two
}
% Now the :Nx version
% ----------------------------------------------------------------------
%   Arguments: A, B. Temp holds: ABC
%   Arguments: 1, 2. Temp hold: 123
% ----------------------------------------------------------------------
\renewcommand*{\temp}{123}
\SetModuleKeys{
  key one/.code:Nn = 2 {Arguments: #1, #2. Temp holds: \temp\\},
  key two/.code:Nx = 2 {Arguments: #1, #2. Temp holds: \temp},
}

\renewcommand*{\temp}{ABC}
\SetModuleKeys{
  key one = {A} {B},
  key two = {1} {2}
}

% Test five: Values can be required and forbidden with the 
% .value_required: and .value_forbidden: properties.
% ----------------------------------------------------------------------
%   All okay
%   All okay
% ----------------------------------------------------------------------
% ! The key `/module name/key' cannot taken a value: the given input 
%   `Not allowed' is being ignored.
%  
% ! The key `/module name/key' requires a value and is being ignored.
% ----------------------------------------------------------------------
\SetModuleKeys{
  key/.code:n = {All okay\\},
  key/.value_forbidden:,
  key,
  key = Not allowed,
  key/.code:n = #1,
  key/.value_required:,
  key = {All okay},
  key
}

% Test six: Keys can be given a default value, to be used if nothing is
% specified by the user.
% ----------------------------------------------------------------------
%   Default
%   Real
%   Default
% ----------------------------------------------------------------------
\SetModuleKeys{
  key/.code:n = {#1\\},
  key/.default:n = Default,
  key,
  key = Real,
  key
}

% Test seven: Keys can be created to store data tlp variable both 
% locally and globally.
% ----------------------------------------------------------------------
%   Some content
%   Outside
%   Some content
%   Some content
% ----------------------------------------------------------------------
\renewcommand*{\temp}{Outside}
\SetModuleKeys{
  key one/.tlp_set:N = \temp,
}
\begingroup
\SetModuleKeys{
  key = Some content
}
\temp\\
\endgroup
\temp\\
\SetModuleKeys{
  key/.tlp_gset:N = \temp
}
\begingroup
\SetModuleKeys{
  key = Some content
}
\temp\\
\endgroup
\temp\\

% Test eight: An expanded version of .tkp_set:N is available.
% ----------------------------------------------------------------------
%   Unexpanded
%   Expanded
% ----------------------------------------------------------------------
\renewcommand*{\temp}{Expanded}
\newcommand*{\tempa}{}
\newcommand*{\tempb}{}
\SetModuleKeys{
  key one/.tlp_set:N   = \tempa,
  key two/.tlp_set_x:N = \tempb,
  key one = \temp,
  key two = \temp,
}
\renewcommand*{\temp}{Unexpanded}
\tempa\\
\tempb\\

% Test nine: Storage functions for int, skip and toks variables are also
% available. Both local and global setting is possible, although there
% are no "x" versions.
% ----------------------------------------------------------------------
%   12345
%   10.00002pt
%   abc
% ----------------------------------------------------------------------
\newcount\tempint
\newskip\tempskip
\newtoks\temptoks
\SetModuleKeys{
  key/.int_set:N  = \tempint,
  key = 12345,
  key/.skip_set:N = \tempskip,
  key = 1 em,
  key/.toks_set:N = \temptoks,
  key = abc
}
\the\tempint\\
\the\tempskip\\
\the\temptoks

% Test ten: Variables can be identified only by the unique part of their
% name, provided that /keys/current_module:n has been set with the
% appropriate information. Both local and global names can be used in
% this way.
% ----------------------------------------------------------------------
%   Local
%   Global
% ----------------------------------------------------------------------
\ExplSyntaxOn
\tlp_new:N \l_module_local_tlp 
\tlp_new:N \g_module_global_tlp
\ExplSyntaxOff
\SetModuleKeys{
  /keys/current_module:n = module,
  key one/.tlp_set:n = local,
  key two/.tlp_gset:n = global,
  key one = Local,
  key two = Global
}
\ExplSyntaxOn
\l_module_local_tlp \\
\g_module_global_tlp
\ExplSyntaxOff

% Test eleven: Boolean keys are created in the same way as other storage
% keys. However, the key will then only accept "true" and "false" as
% input. The key name can be given alone, resulting in the switch being
% set "true".
% ----------------------------------------------------------------------
% Local switch true
% Global switch true
% ----------------------------------------------------------------------
% ! Key `/module name/key one' takes the Boolean values `true' and 
% `false' only. The given value `rubbish' is being ignored.
% ----------------------------------------------------------------------
\ExplSyntaxOn
\bool_new:N \localbool
\bool_new:N \g_module_global_bool
\ExplSyntaxOff
\SetModuleKeys{
  /keys/current_module:n = module,
  key one/.bool_set:N = \localbool,
  key two/.bool_gset:n = global,
  key one = true,
  key two = false,
  key two,
  key one = rubbish
}
\ExplSyntaxOn
\bool_if:NTF \localbool { Local~switch~true } { Local~switch~false } \\
\bool_if:NTF \g_module_global_bool 
  { Global~switch~true } { Global~switch~false }
\ExplSyntaxOff

\end{document}

