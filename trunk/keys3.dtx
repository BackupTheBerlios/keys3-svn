% \iffalse meta-comment
% !TEX program  = pdflatex
% !TEX encoding = ISO-8859-1
%<*internal>
\iffalse
%</internal>
%<*readme>
---------------------------------------------------------------
The keys3 package --- Key management for LaTeX3
Maintained by Joseph Wright 
E-mail: joseph.wright@morningstar2.co.uk
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
---------------------------------------------------------------

The keys3 package is an experimental implementation of key
management for LaTeX3.  The entire package is written in
expl3 code rather than in traditional TeX/LaTeX.  The key
model used by keys3 is based on the idea that keys are created
by setting key properties:

  \keys_define:nn { module } { 
    key .code:n = Hello #1,
    key .value_required:
  }

The keys3 package is intended as a method for testing how key
management might be implemented in LaTeX3.  Both the methods
used inside the package and the interface provided are intended
to be discussed.  Feedback is welcomed either by e-mail
(joseph.wright@morningstar2.co.uk) or to the LaTeX-L mailing
list.

The experimental nature of keys3 means that it should not be 
used in production documents.  However, programmers testing 
expl3, or keen to work on improved key management systems, 
are encouraged to try the package and provide feedback.

keys3 is *not* an official LaTeX3 team package.  Whether any of
the ideas explored here will be taken up by the team is
therefore unknown.  However, the keys3 package should provide
ideas on what needs to be available for key management and how
it can be implemented.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
---------------------------------------------------------------
The keys3 package --- Key management for LaTeX3
Maintained by Joseph Wright 
E-mail: joseph.wright@morningstar2.co.uk
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
---------------------------------------------------------------

EXPERIMENTAL CODE

Do not distribute this file without also distributing the
source files specified above.

Do not distribute a modified version of this file.

\endpreamble
\postamble

Copyright (C) 2008-2009 by
  Joseph Wright <joseph.wright@morningstar2.co.uk>

It may be distributed and/or modified under the conditions of
the LaTeX Project Public License (LPPL), either version 1.3c of
this license or (at your option) any later version.  The latest
version of this license is in the file:

   http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
  Joseph Wright.

This work consists of the file  keys3.dtx
          and the derived files keys3.pdf,
                                keys3.sty and
                                keys3.ins.

\endpostamble
\usedir{tex/latex/keys3}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/keys3}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/keys3}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {Key management for LaTeX3}
%</driver|package>
%\fi
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
  \DocInput{\filename.\filenameext}
\end{document}
%</driver>
% \fi
%
%\title{The \pkg{keys3} package^^A
%  \thanks{This file has version number \fileversion, last
%    revised \filedate.}\\
%  Key management for \LaTeX3
%}
%\author{Joseph Wright^^A
%  \thanks{E-mail: joseph.wright@morningstar2.co.uk}}
%\date{\filedate}
% 
%\maketitle
% 
%\begin{documentation}
%
%\section{Key management}
%
% The key--value method is a popular system for creating large numbers
% of settings for controlling function or package behaviour.  For the
% user, the system normally results in input of the form
%\begin{verbatim}
%  \PackageControlMacro{
%    key-one = value one,
%    key-two = value two
%  }
%\end{verbatim}
% or
%\begin{verbatim}
%  \PackageMacro[
%    key-one = value one,
%    key-two = value two
%  ]{argument}.
%\end{verbatim}
% For the programmer, the original \pkg{keyval} package gives only
% the most basic interface for this work.  All key macros have to be
% created one at a time, and as a result the \pkg{kvoptions} and
% \pkg{xkeyval} packages have been written to extend the ease of
% creating keys.  A very different approach has been provided by
% the \pkg{pgfkeys} package, which uses a key--value list to
% generate keys.
% 
% The \pkg{keys3} package is aimed at creating a programming 
% interface for key--value controls in \LaTeX3. Keys are
% created using a key--value interface, in a similar manner to 
% \pkg{pgfkeys}. Each key is created by setting one or more
% \emph{properties} of the key:
%\begin{verbatim}
%  \keys_define:nn { module }
%    key-one .code:n = code including parameter #1,
%    key-two .set    = \l_module_store_tl
%  }
%\end{verbatim}
% These values can then be set as with other key--value approaches:
%\begin{verbatim}
%  \keys_set:nn { module }
%    key-one = value one,
%    key-two = value two
%  }
%\end{verbatim}
%
% At a document level, \cs{keys_set:nn} is used within a  
% document function. For \LaTeXe, a generic set up function could be 
% created with
%\begin{verbatim}
%  \newcommand*\SomePackageSetup[1]{%
%    \@nameuse{keys_set:nn}{module}{#1}%
%  }
%\end{verbatim}
% or to use key--value input as the optional argument for a macro:
%\begin{verbatim}
%  \newcommand*\SomePackageMacro[2][]{%
%    \begingroup
%      \@nameuse{keys_set:nn}{module}{#1}%
%      % Main code for \SomePackageMacro
%    \endgroup
%  }
%\end{verbatim} 
% The same concepts using \pkg{xparse} for \LaTeX3 use:
%\begin{verbatim}
%  \DeclareDocumentCommand \SomePackageSetup { m } {
%    \keys_set:nn { module } { #1 }
%  }
%  \DeclareDocumentCommand \SomePackageMacro { o m } {
%    \group_begin:
%      \keys_set:nn { module } { #1 }
%      % Main code for \SomePackageMacro
%    \group_end:
%  }
%\end{verbatim}
%
% Key names may contain any tokens, as they are handled internally
% using \cs{tl_to_str:n}. As will be discussed in 
% section~\ref{sec:subdivision}, it is suggested that the character 
% ``\texttt{/}'' is reserved for sub-division of keys into logical
% groups. Macros are \emph{not} expanded when creating key names,
% and so
%\begin{verbatim}
%  \tl_set:Nn \l_module_tmp_tl { key }
%  \keys_define:nn { module } {
%    \l_module_tmp_tl .code:n = code
%  }
%\end{verbatim} 
% will create a key called \cs{l_module_tmp_tl}, and not one called
% \texttt{key}.
%
%\subsection{Creating keys}
%
%\begin{function}{\keys_define:nn}
%  \begin{syntax}
%    "\keys_define:nn" <module> <keyval list>
%  \end{syntax}
%  Parses the <keyval list> and defines the keys listed there for
%  <module>. This function is designed for use in code, and therefore
%  does  not check the category codes of characters or ignore spaces.
%\end{function}
% 
% Setting up and altering keys is carried out using one or more
% properties. The properties determine how a key acts, and may require 
% zero, one or two argument: this is indicated by an argument specifier,
% in the same way as a standard \LaTeX3 function. If only a single
% argument is required, braces around \texttt{n} arguments can be
% omitted.\footnote{This is a general feature of key--value input 
% methods.}
% 
%\begin{function}{.choice:}
%  \begin{syntax}
%    <key> .choice:
%  \end{syntax}
%  Sets <key> to act as a multiple choice key. Creating choices 
%  is discussed in section~\ref{sec:choice}.
%\end{function}
%
%\begin{function}{
%   .code:n|
%   .code:x
%  }
%  \begin{syntax}
%    <key> .code:n = <code>
%  \end{syntax}
%  Stores the <code> for execution when <key> is called. The <code> can
%  include one parameter (|#1|), which will be the <value> given for the
%  <key>.
%\end{function}
% 
%\begin{function}{
%   .code:Nn|
%   .code:Nx
% }
%  \begin{syntax}
%    <key> .code:Nn = <number> <code>
%  \end{syntax}
%  Stores the <code> for execution when <key> is called. The <code> can
%  include <number> parameters, which can be in the standard \TeX\ 
%  range 0--9. If too few parameters are given when the key is used, 
%  sufficient empty groups will be supplied to prevent an error
%  occurring.
%\end{function}
% 
%\begin{function}{
%   .default:n|
%   .default:V|
%  }
%  \begin{syntax}
%    <key> .default:n = <default>
%  \end{syntax}
%  Creates a <default> value for <key>, which is used if no value is 
%  given. This will be used if only the key name is given, but not if
%  a blank <value> is given:
%  \begin{verbatim}
%    \keys_define:nn { module } {
%      key .code:n  = Hello #1,
%      key .default = World
%    }
%    \keys_set:nn { module} {
%      key = Fred, % Prints "Hello Fred"
%      key,        % Prints "Hello World"
%      key = ,     % Prints "Hello "
%    }
%  \end{verbatim}
%  \begin{texnote}
%    The <default> is stored as a token list variable.
%  \end{texnote}
%\end{function}
% 
%\begin{function}{
%   .generate_choices:nn|
%   .generate_choices:nx|
% }
%  \begin{syntax}
%    <key> .generate_choices:nn = <comma list> <code>
%  \end{syntax}
%  Makes <key> a multiple choice key, accepting the choices specified
%  in <comma list>. Each choice will execute <code> if it given. Within
%  <code>, the name of the current choice is available as 
%  \cs{l_keys_choice_tl},  and its position in the <comma list> as 
%  \cs{l_keys_choice_int}. Multiple choices are discussed further in 
%  section~\ref{sec:choice}.
%\end{function}
% 
%\begin{function}{
%   .set:N|
%   .set_x:N
%}
%  \begin{syntax}
%    <key> .set:N = <variable>
%  \end{syntax}
%  Defines <key> to store the value given in <variable>. The type and 
%  scope (local or global) of <variable> are determined from the 
%  name. The \texttt{x} version performs an expanded assignment. For
%  example
%  \begin{verbatim}
%    \keys_define:nn { module } {
%      key-one .set:N = \l_module_tmpa_tl,  % Locally sets a tl var.
%      key_two .set:N = \g_module_tmpa_toks % Globally sets a toks
%    }
%    \keys_set:nn { module } {
%      key-one = Value, % \l_module_tmpa_tl contains "Value"
%      key-two = Stuff  % \g_module_tmpa_toks contains "Stuff"
%    }
%  \end{verbatim}
%  Assignments are automatically global for global variables. 
%  
%  A  \cs{<variable>_set:Nn} function must exist to allow setting of the
%  <variable>. An error will result if this is not the case. The 
%  \texttt{.set_x:N} version can only be applied to variable types which
%  have a \cs{<variable>_set:Nx} function: other cases will result in an 
%  error.
%\end{function}
% 
%\begin{function}{
%   .set_bool:N|
%   .set_bool_inverse:N|
% }
%  \begin{syntax}
%    <key> .set_bool:N = <bool>
%    <key> .set_bool_inverse:N = <bool>
%  \end{syntax}
%  Defines <key> to set <bool> to <value> (which must be either 
%  \texttt{true} or \texttt{false}). The \texttt{inverse} version sets
%  the switch to the opposite logical sense to the argument given.
%\end{function}
% 
%\begin{function}{
%   .value_forbidden:|
%   .value_required:|
% }
%  \begin{syntax}
%    <key> .value_forbidden:
%  \end{syntax}
%  Flags for forbidding and requiring a <value> for <key>. Any <value>
%  given will be ignored.
%\end{function}
%
%\subsection{Sub-dividing keys}
%\label{sec:subdivision}
%
% When creating large numbers of keys, it may be desirable to divide 
% them into several sub-groups for a given module. This can be achieved
% either by adding a sub-division to the module name:
%\begin{verbatim}
%  \keys_define:nn { module / subgroup } {
%    key .code:n = code
%  }
%\end{verbatim} 
% or to the key name:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    subgroup / key .code:n = code
%  }
%\end{verbatim}  
% As illustrated, the best choice of token for sub-dividing keys in
% this way is ``\texttt{/}''. This is because of the method that is
% used to represent keys internally. Both of the above code fragments
% set the same key, which has full name \texttt{module/subgroup/key}.
% 
% As will be illustrated in the next section, this subdivision is
% particularly relevant to making multiple choices.
%
%\subsection{Multiple choices}
%\label{sec:choice}
%
% In \pkg{keys3}, multiple choices are created by setting the 
% \texttt{.choice:} property:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key .choice:
%  }
%\end{verbatim}
% For keys which are set up as choices, the valid choices are generated
% by creating sub-keys of the choice key. This can be carried out in
% two ways.
% 
% In many cases, choices execute similar code which is dependant only 
% on the name of the choice or the position of the choice in the
% list of choices. Here, the keys can share the same code, and can
% be rapidly created using the \texttt{.generate_choices:nn}
% property:
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key .generate_choices:nn = {
%      choice-a, choice-b, choice-c
%    } {
%      You~gave~choice~``\l_keys_choice_tl'',~
%      which~is~in~position~\l_keys_choice_int
%      \~in~the~list.
%    }
%  }
%\end{verbatim}
% 
%\begin{variable}{
%  \l_keys_choice_tl|
%  \l_keys_choice_int|
%}
%  Inside the code block, the variables \cs{l_keys_choice_tl} and
%  \cs{l_keys_choice_int} are available to indicate the name of the
%  current choice, and its position in the comma list.  The position
%  is indexed from \(1\).
%\end{variable}
%
% On the other hand, it is sometimes useful to create choices which
% use entirely different code from one another. This can be achieved
% by setting the \texttt{.choice:} property of a key, then manually
% defining sub-keys.
%\begin{verbatim}
%  \keys_define:nn { module } {
%    key choices:n,
%    key / choice-a .code:n = code-a,
%    key / choice-b .code:n = code-b,
%    key / choice-c .code:n = code-c,
%  }
%\end{verbatim}
%
% It is possible to mix the two methods, but manually-created choices
% should \emph{not} use \cs{l_keys_choice_tl} or \cs{l_keys_choice_int}.
%
%\subsection{Setting keys}
%
%\begin{function}{\keys_set:nn}
%  \begin{syntax}
%    "\keys_set:nn" <module> <keyval list>
%  \end{syntax}
%  Parses the <keyval list>, and sets those keys which are defined
%  for <module>. The behaviour on finding an unknown key can be
%  set by defining a special \texttt{unknown} key: this will be 
%  illustrated later. In contrast to \cs{keys_define:nn}, this function
%  does check category codes and ignore spaces, and is therefore 
%  suitable for user input.
%\end{function}
%
% If a key is not known, \cs{keys_set:nn} will look for a special
% \texttt{unknown} key for the same module. This mechanism can be
% used to create new keys from user input.
%\begin{verbatim}
%  \keys_define:nn { module } {
%    unknown .code:n = 
%      You~tried~to~set~key~`\l_keys_path_tl'~to~`#1'
%  }
%\end{verbatim}
%
%\begin{variable}{\l_keys_key_tl}
%  When processing an unknown key, the name of the key is available
%  as \cs{l_keys_key_tl}. Note that this will have been processed
%  using \cs{tl_to_str:N}. The value passed to the key (if any) is
%  available as the macro parameter |#1|.
%\end{variable}
% 
%\subsection{Examining keys: internal representation}
%
%\begin{function}{\keys_show:nn}
%  \begin{syntax}
%    "\keys_show:nn" <module> <key>
%  \end{syntax}
%  Shows the internal representation of a <key>. The function which
%  executes a <key> is called \cs{keys > <module>/<key>.cmd:w}.
%\end{function}
% 
%\subsection{Internal functions}
%
%\begin{function}{\keys_arguments_tidy:w}
%   \begin{syntax}
%     "\keys_arguments_tidy:w " <args> "\q_keys_stop"
%   \end{syntax}
%   Clears <args> from the stack: used to clean up after executing a
%   key.
%\end{function}
%
%\begin{function}{
%    \keys_bool_set:N |
%    \keys_bool_set_inverse:N
%}
%   \begin{syntax}
%     "\keys_bool_set:N" <bool>
%   \end{syntax}
%   Creates code to set <bool> when <key> is given.
%\end{function}
%
%\begin{function}{\keys_choice_make:}
%   \begin{syntax}
%     "\keys_choice_make:" 
%   \end{syntax}
%   Makes <key> a choice key.
%\end{function}
%
%\begin{function}{\keys_choices_generate:nx}
%   \begin{syntax}
%     "\keys_choices_generate:nx" <comma list> <code>
%   \end{syntax}
%   Makes <comma list> choices for <key>, each using <code>.
%\end{function}
%
%\begin{function}{\keys_choice_find:n}
%   \begin{syntax}
%     "\keys_choice_find:n" <choice>
%   \end{syntax}
%   Searches for <choice> as a sub-key of <key>.
%\end{function}
%
%\begin{function}{
%    \keys_cmd_set:nNn |
%    \keys_cmd_set:nNx
%}
%   \begin{syntax}
%     "\keys_cmd_set:nNn" <path> <num args> <code>
%   \end{syntax}
%   Creates a function for <path>, taking <num args> and using <code>.
%\end{function}
%
%\begin{function}{
%    \keys_default_set:n |
%    \keys_default_set:V
%}
%   \begin{syntax}
%     "\keys_default_set:n" <default>
%   \end{syntax}
%   Sets <default> for <key>.
%\end{function}
%
%\begin{function}{
%    \keys_define_elt:n |
%    \keys_define_elt:nn
%}
%   \begin{syntax}
%     "\keys_define_elt:n" <key> <value>
%   \end{syntax}
%   Processing functions for key--value pairs when defining keys.
%\end{function}
%
%\begin{function}{\keys_define_key:n}
%   \begin{syntax}
%     "\keys_define_key:n" <key>
%   \end{syntax}
%   Defines <key>.
%\end{function}
%
%\begin{function}{\keys_execute:}
%   \begin{syntax}
%     "\keys_execute:" 
%   \end{syntax}
%   Executes <key>.
%\end{function}
%
%\begin{function}{\keys_execute_unknown:}
%   \begin{syntax}
%     "\keys_execute_unknown:" 
%   \end{syntax}
%   Handles unknown <key> names.
%\end{function}
%
%\begin{function}{\keys_if_value_requirement:nTF}
%   \begin{syntax}
%     "\keys_if_value_requirement:nTF" <requirement>
%     ~~~~<true code> <false code>
%   \end{syntax}
%   Check if <requirement> applies to <key>.
%\end{function}
%
%\begin{function}{\keys_property_find:n}
%   \begin{syntax}
%     "\keys_property_find:n" <key>
%   \end{syntax}
%   Separates <key> from <property>.
%\end{function}
%
%\begin{function}{\keys_property_new:nn}
%   \begin{syntax}
%     "\keys_property_new:nn" <property> <code>
%   \end{syntax}
%   Makes a new <property> expanding to <code>
%\end{function}
%
%\begin{function}{\keys_property_undefine:n}
%   \begin{syntax}
%     "\keys_property_undefine:n" <property>
%   \end{syntax}
%   Deletes <property> of <key>.
%\end{function}
%
%\begin{function}{
%    \keys_set_elt:n  |
%    \keys_set_elt:nn 
%}
%   \begin{syntax}
%     "\keys_set_elt:n" <key> <value>
%   \end{syntax}
%   Processing functions for key--value pairs when setting keys.
%\end{function}
%
%\begin{function}{\keys_tmp:w}
%   \begin{syntax}
%     "\keys_tmp:w" <args>
%   \end{syntax}
%   Used to store <code> to execute a <key>.
%\end{function}
%
%\begin{function}{\keys_value_or_default:n}
%   \begin{syntax}
%     "\keys_value_or_default:n" <value>
%   \end{syntax}
%   Sets \cs{l_keys_value_toks} to <value>, or <default> if
%   <value> was not given and if <default> is available.
%\end{function}
%
%\begin{function}{\keys_value_requirement:n}
%   \begin{syntax}
%     "\keys_value_requirement:nn" <requirement>
%   \end{syntax}
%   Sets <key> to have <requirement> concerning <value>.
%\end{function}
%
%\begin{function}{\keys_variable_set:NN}
%   \begin{syntax}
%     "\keys_variable_set:NN" <expansion> <var>
%   \end{syntax}
%   Sets <key> to assign <value> to <variable>
%\end{function}
% 
%\begin{function}{
%    \keys_variable_get_scope:N / (EXP) |
%    \keys_variable_get_type:N  / (EXP)
%}
%   \begin{syntax}
%     "\keys_variable_get_scope:N" <var>
%   \end{syntax}
%   Returns the scope (\texttt{g} or blank) or the type of <var>.
%\end{function}
% 
%\subsection{Variables and constants}
%
%\begin{variable}{
%  \c_keys_properties_root_tl|
%  \c_keys_root_tl
%}
%  The root paths for keys and properties.
%\end{variable}
% 
%\begin{variable}{
%  \c_keys_value_forbidden_tl|
%  \c_keys_value_required_tl
%}
%  Marker text containers. 
%\end{variable}
% 
%\begin{variable}{
%  \l_keys_module_tl|
%  \l_keys_path_tl|
%  \l_keys_property_tl
%}
%  Various key paths need to be stored.
%\end{variable}
%
%\begin{variable}{\l_keys_no_value_bool}
%  A marker for ``no value'' as key input.
%\end{variable}
%
%\begin{variable}{\l_keys_value_toks}
%  Holds the currently supplied value.
%\end{variable}
%
%\begin{variable}{\q_keys_stop}
%  A private quark for delimiting arguments.
%\end{variable}
% 
%\end{documentation}
% 
%\begin{implementation}
%
% The usual preliminaries.  
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%    \end{macrocode}
%
%\subsubsection{Variables and constants}
%
%\begin{macro}{\c_keys_root_tl}
%\begin{macro}{\c_keys_properties_root_tl}
% Where the keys are really stored.
%    \begin{macrocode}
\tl_new:Nn \c_keys_root_tl { keys~>~ }
\tl_new:Nn \c_keys_properties_root_tl { keys_properties }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\c_keys_value_forbidden_tl}
%\begin{macro}{\c_keys_value_required_tl}
% Two marker token lists.
%    \begin{macrocode}
\tl_new:Nn \c_keys_value_forbidden_tl { forbidden }
\tl_new:Nn \c_keys_value_required_tl { required }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_choice_int}
%\begin{macro}{\l_keys_choice_tl}
% Used for the multiple choice system.
%    \begin{macrocode}
\int_new:N \l_keys_choice_int
\tl_new:N \l_keys_choice_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_key_tl}
%\begin{macro}{\l_keys_path_tl}
%\begin{macro}{\l_keys_property_tl}
% Storage for the current key name and the path of the key (key name 
% plus module name).
%    \begin{macrocode}
\tl_new:N \l_keys_key_tl
\tl_new:N \l_keys_path_tl
\tl_new:N \l_keys_property_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_module_tl}
% The module for an entire set of keys.
%    \begin{macrocode}
\tl_new:N \l_keys_module_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_keys_no_value_bool}
% To indicate that no value has been given.
%    \begin{macrocode}
\bool_new:N \l_keys_no_value_bool
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_keys_value_toks}
% A token register for the given value.
%    \begin{macrocode}
\toks_new:N \l_keys_value_toks
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\q_keys_stop}
% A quark for delimiting keys: no one else should use it!
%    \begin{macrocode}
\quark_new:N \q_keys_stop
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Internal functions}
%
%\begin{macro}{\keys_arguments_tidy:w}
% So that nothing runs away, a safety precaution is taken in the code.
%    \begin{macrocode}
\cs_new:Npn \keys_arguments_tidy:w #1 \q_keys_stop { }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_bool_set:N}
%\begin{macro}{\keys_bool_set_inverse:N}
%\begin{macro}[aux]{\keys_bool_set_aux:N}
% Boolean keys are really just choices, but all done by hand.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_bool_set:N {
  \keys_cmd_set:nNx { \l_keys_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N } 
      \exp_not:N #1
  }
  \keys_cmd_set:nNx { \l_keys_path_tl / false } 1 {
    \exp_not:N \use:c 
      { bool_ \keys_variable_get_scope:N #1 set_false:N } 
      \exp_not:N #1
  }
  \keys_bool_set_aux:N #1
}
\cs_new_nopar:Nn \keys_bool_set_inverse:N {
  \keys_cmd_set:nNx { \l_keys_path_tl / true } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_false:N }
      \exp_not:N #1
  }
  \keys_cmd_set:nNx { \l_keys_path_tl / false } 1 {
    \exp_not:c { bool_ \keys_variable_get_scope:N #1 set_true:N }
      \exp_not:N #1
  }
  \keys_bool_set_aux:N #1
}
\cs_new_nopar:Nn \keys_bool_set_aux:N {
  \keys_choice_make:
  \cs_if_exist:NF #1 {
    \bool_new:N #1
  }
  \keys_default_set:n { true }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_choice_find:n}
% Executing a choice has two parts. First, try the choice given, then
% if that fails call the unknown key. That will exist, as it is created
% when a choice is first made. So there is no need for any escape code.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_choice_find:n {
  \keys_execute_aux:nn { \l_keys_path_tl / #1 } {
    \keys_execute_aux:nn { \l_keys_path_tl / unknown } { }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_choice_make:}
% To make a choice from a key, two steps: set the code, and set the 
% unknown key.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_choice_make: {
  \keys_cmd_set:nNn { \l_keys_path_tl } 1 {
    \keys_choice_find:n {##1}
  }
  \keys_cmd_set:nNn { \l_keys_path_tl / unknown } 1 {
    \msg_error:nnxx { keys } { choice~unknown }
      { \l_keys_path_tl } {##1} 
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_choices_generate:nx}
%\begin{macro}[aux]{\keys_choices_generate_aux:n}
% Creating multiple-choices means setting up the ``indicator'' code,
% then applying whatever the user wanted.
%    \begin{macrocode}
\cs_new:Nn \keys_choices_generate:nx {
  \keys_choice_make:
  \int_zero:N \l_keys_choice_int
  \cs_set_nopar:Nn \keys_choices_generate_aux:n {
    \int_incr:N \l_keys_choice_int
    \keys_cmd_set:nNx { \l_keys_path_tl / ##1 } 1 {
      \exp_not:n { \tl_set:Nn \l_keys_choice_tl } {##1}
      \exp_not:n { \int_set:Nn \l_keys_choice_int }
        { \int_use:N \l_keys_choice_int }
      #2
    }
  }
  \clist_map_function:nN {#1} \keys_choices_generate_aux:n 
}
\cs_new_nopar:Nn \keys_choices_generate_aux:n { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_cmd_set:nNn}
%\begin{macro}{\keys_cmd_set:nNx}
%\begin{macro}[aux]{\keys_cmd_set_aux:nN}
% Creating a new command means setting properties and then creating
% a function with the correct number of arguments.
%    \begin{macrocode}
\cs_new:Nn \keys_cmd_set:nNn {
  \keys_cmd_set_aux:nN {#1} #2
  \cs_generate_from_arg_count:cNnn { \c_keys_root_tl #1 .cmd:w } 
    \cs_set:Npn #2 { #3 \keys_arguments_tidy:w }
}
\cs_new:Nn \keys_cmd_set:nNx {
  \keys_cmd_set_aux:nN {#1} #2
  \cs_generate_from_arg_count:cNnn { \c_keys_root_tl #1 .cmd:w } 
    \cs_set:Npx #2 { #3 \exp_not:N \keys_arguments_tidy:w }
}
\cs_new_nopar:Nn \keys_cmd_set_aux:nN {
  \keys_property_undefine:n { #1 .default_tl }
  \num_set:cn { \c_keys_root_tl #1 .args_num } {#2}
  \tl_set:cn  { \c_keys_root_tl #1 .req_tl } { } 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_default_set:n}
%\begin{macro}{\keys_default_set:V}
% Setting a default value is easy.
%    \begin{macrocode}
\cs_new:Nn \keys_default_set:n {
  \tl_set:cn { \c_keys_root_tl \l_keys_path_tl .default_tl } {#1}
}
\cs_generate_variant:Nn \keys_default_set:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_define:nn}
% The main key-defining function mainly sets up things for \pkg{l3keyval}
% to use.
%    \begin{macrocode}
\cs_new:Nn \keys_define:nn {
  \tl_set:Nn \l_keys_module_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \keys_define_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \keys_define_elt:nn
  \KV_parse_no_space_removal_no_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_define_elt:n}
%\begin{macro}{\keys_define_elt:nn}
% The element processors for defining keys.
%    \begin{macrocode}
\cs_new:Nn \keys_define_elt:n {
  \bool_set_true:N \l_keys_no_value_bool
  \keys_define_elt_aux:nn {#1} { }
}
\cs_new:Nn \keys_define_elt:nn {
  \bool_set_false:N \l_keys_no_value_bool
  \keys_define_elt_aux:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\keys_define_elt_aux:nn}
% The auxiliary function does most of the work.
%    \begin{macrocode}
\cs_new:Nn \keys_define_elt_aux:nn {
  \keys_property_find:n {#1}
  \cs_set_eq:Nc \keys_tmp:w 
    { \c_keys_properties_root_tl \l_keys_property_tl }
  \cs_if_exist:NTF \keys_tmp:w {
    \keys_define_key:n {#2}
  }{
    \msg_error:nnx { keys } { property~unknown } 
      { \l_keys_property_tl }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_define_key:n}
% Defining a new key means finding the code for the appropriate 
% property then running it. As properties have signatures, a check
% can be made for required values without needing anything set
% explicitly.
%    \begin{macrocode}
\cs_new:Nn \keys_define_key:n {
  \bool_if:NTF \l_keys_no_value_bool {
    \intexpr_compare:nTF { 
      \exp_args:Nc \cs_get_arg_count_from_signature:N 
        { \l_keys_property_tl } = \c_zero
    } {
      \keys_tmp:w \q_keys_stop
    }{
      \msg_error:nnx { keys } { property~value~required } 
        { \l_keys_property_tl }
    }  
  }{
    \intexpr_compare:nTF { 
      \exp_args:Nc \cs_get_arg_count_from_signature:N 
        { \l_keys_property_tl }  = \c_one
    } {
      \keys_tmp:w {#1} \q_keys_stop
    }{
      \keys_tmp:w #1 { } { } { } { } { } { } { } { } { } \q_keys_stop
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_execute:}
%\begin{macro}{\keys_execute_unknown:}
%\begin{macro}[aux]{\keys_execute_aux:nn}
% Actually executing a key is done in two parts. First, look for the
% key itself, then look for the \texttt{unknown} key with the same
% path. If both of these fail, complain!
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_execute: {
  \keys_execute_aux:nn { \l_keys_path_tl } {
    \keys_execute_unknown:
  }
}
\cs_new_nopar:Nn \keys_execute_unknown: {
  \keys_execute_aux:nn { \l_keys_module_tl / unknown } {
    \msg_error:nnx { keys } { key~unknown } { \l_keys_path_tl }
  }
}
%    \end{macrocode}
% If there is only one argument required, it is wrapped in braces so
% that everything is passed through properly. On the other hand, if more
% than one is needed it is down to the user to have put things in 
% correctly! The use of \cs{q_keys_stop} here means that arguments
% do not run away (hence the nine empty groups), but that the module
% can clean up the spare groups at the end of executing the key.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_execute_aux:nn {
  \cs_set_eq:Nc \keys_tmp:w { \c_keys_root_tl #1 .cmd:w }
  \cs_if_exist:NTF \keys_tmp:w {
    \intexpr_compare:nTF { 
      \num_use:c { \c_keys_root_tl #1 .args_num } = \c_one
    } {
      \exp_args:NV \keys_tmp:w \l_keys_value_toks \q_keys_stop
    }{
      \exp_after:wN \keys_tmp:w \toks_use:N \l_keys_value_toks
      { } { } { } { } { } { } { } { } { } \q_keys_stop
    }
  }{
    #2
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_if_value_requirement:nTF}
% To test if a value is required or forbidden. Only one version is
% needed, so done by hand.
%    \begin{macrocode}
\cs_new_nopar:Npn \keys_if_value_requirement:nTF #1 {
  \tl_if_eq:ccTF { c_keys_value_ #1 _tl } {
    \c_keys_root_tl \l_keys_path_tl .req_tl
  } 
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_property_find:n}
%\begin{macro}[aux]{\keys_property_find_aux:w}
% Searching for a property means finding the last ``\texttt{.}'' in
% the input, and storing the text before and after it.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_find:n {
  \tl_set:Nx \l_keys_path_tl { \l_keys_module_tl / }
  \tl_if_in:nnTF {#1} {.} {
    \keys_property_find_aux:n {#1}
  }{
    \msg_error:nnx { keys } { no~property } { #1 }
  }
}
\cs_new_nopar:Nn \keys_property_find_aux:n {
  \keys_property_find_aux:w #1 \q_stop
}
\cs_new_nopar:Npn \keys_property_find_aux:w #1 . #2 \q_stop {
  \tl_if_in:nnTF {#2} {.} {
    \tl_set:Nx \l_keys_path_tl { 
      \l_keys_path_tl . \tl_to_str:n {#1}
    }
    \keys_property_find_aux:w #2 \q_stop
  }{
    \tl_set:Nx \l_keys_path_tl { \l_keys_path_tl \tl_to_str:n {#1} }
    \tl_set:Nn \l_keys_property_tl { . #2 }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_property_new:nn}
% Creating a new propery is simply a case of making the correctly-named
% function.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_new:nn {
  \cs_new:cn { \c_keys_properties_root_tl #1 } 
    { #2 \keys_arguments_tidy:w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_property_undefine:n}
% Removing a property means undefining it.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_property_undefine:n {
  \cs_set_eq:cN { \c_keys_root_tl #1 } \c_undefined
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_set:nn}
% The main setting function just does the set up to get \pkg{l3keyval}
% to do the hard work.
%    \begin{macrocode}
\cs_new:Nn \keys_set:nn {
  \tl_set:Nn \l_keys_module_tl {#1}
  \cs_set_eq:NN \KV_key_no_value_elt:n \keys_set_elt:n
  \cs_set_eq:NN \KV_key_value_elt:nn \keys_set_elt:nn
  \KV_parse_space_removal_sanitize:n {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_set_elt:n}
%\begin{macro}{\keys_set_elt:nn}
% The two element processors are almost identical, and pass the data 
% through to the underlying auxiliary, which does the work.
%    \begin{macrocode}
\cs_new:Nn \keys_set_elt:n {
  \bool_set_true:N \l_keys_no_value_bool
  \keys_set_elt_aux:nn {#1} { }
}
\cs_new:Nn \keys_set_elt:nn {
  \bool_set_false:N \l_keys_no_value_bool
  \keys_set_elt_aux:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\keys_set_elt_aux:nn}
%\begin{macro}[aux]{\keys_set_elt_aux:}
% First, set the current path and add a default if needed. There are 
% then checks to see if the a value is required or forbidden. If 
% everything passes, move on to execute the code.
%    \begin{macrocode}
\cs_new:Nn \keys_set_elt_aux:nn {
  \tl_set:Nx \l_keys_key_tl { \tl_to_str:n {#1} }
  \tl_set:Nx \l_keys_path_tl { \l_keys_module_tl / \l_keys_key_tl }
  \keys_value_or_default:n {#2}
  \keys_if_value_requirement:nTF { required } {
    \bool_if:NTF \l_keys_no_value_bool {
      \msg_error:nnx { keys }  { key~value~required } 
        { \l_keys_path_tl }
    }{
      \keys_set_elt_aux:
    }
  }{
    \keys_set_elt_aux:
  } 
}
\cs_new_nopar:Nn \keys_set_elt_aux: {
  \keys_if_value_requirement:nTF { forbidden } {
    \bool_if:NTF \l_keys_no_value_bool {
      \keys_execute:
    }{
      \msg_error:nnxx { keys} { key~value~forbidden } 
        { \l_keys_path_tl }
        { \toks_use:N \l_keys_value_toks }
    }
  }{
    \keys_execute:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_show:nn}
% Showing a key is just a question of using the correct name.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_show:nn {
  \cs_show:c { \c_keys_root_tl #1 / \tl_to_str:n {#2} .cmd:w }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_tmp:w}
% This scratch function is used to actually execute keys.
%    \begin{macrocode}
\cs_new:Npn \keys_tmp:w {}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_value_or_default:n}
% If a value is given, return it as |#1|, otherwise send a default if
% available.
%    \begin{macrocode}
\cs_new:Nn \keys_value_or_default:n {
  \toks_set:Nn \l_keys_value_toks  {#1}
  \bool_if:NT \l_keys_no_value_bool {
    \cs_if_exist:cT { \c_keys_root_tl \l_keys_path_tl .default_tl } {
      \toks_set:Nv \l_keys_value_toks  { 
        \c_keys_root_tl \l_keys_path_tl .default_tl 
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_value_requirement:n}
% Values can be required or forbidden by having the appropriate marker
% set.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_value_requirement:n { 
  \tl_set_eq:cc { \c_keys_root_tl \l_keys_path_tl .req_tl } 
    { c_keys_value_ #1 _tl }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_variable_get_scope:N}
%\begin{macro}[aux]{\keys_variable_get_scope_aux:w}
%\begin{macro}{\keys_variable_get_type:N}
%\begin{macro}[aux]{\keys_variable_get_type:w}
% Expandable functions to find the type of a variable, and to 
% return \texttt{g} if the variable is global. The trick for 
% \cs{keys_variable_get_scope:N} is the same as that in 
% \cs{cs_split_function:NN}, but it can be simplified as the
% requirements here are less complex.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn {`\&} {`\g}
  \char_make_other:N \&
\tl_to_lowercase:n {
  \group_end:
  \cs_new_nopar:Nn \keys_variable_get_scope:N {
    \exp_last_unbraced:Nf \keys_variable_get_scope_aux:w
    { \cs_to_str:N #1 \exp_stop_f: & a \q_nil }
  }
  \cs_new:Npn \keys_variable_get_scope_aux:w #1 & #2#3 \q_nil {
    \token_if_eq_meaning:NNF a #2 {g}
  }
}
\group_begin:
  \char_set_lccode:nn {`\&} {`\_}
  \char_make_other:N \&
\tl_to_lowercase:n {
  \group_end:
  \cs_new_nopar:Nn \keys_variable_get_type:N {
    \exp_after:wN \keys_variable_get_type_aux:w 
      \token_to_str:N #1 & a \q_nil 
  }
  \cs_new_nopar:Npn \keys_variable_get_type_aux:w #1 & #2#3 \q_nil {
    \token_if_eq_meaning:NNTF a #2 {
      #1
    }{
      \keys_variable_get_type_aux:w #2#3 \q_nil
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_variable_set:NN}
% To set a variable, there is first a check so that it must exist.
% The setting function is then created by recovering the type and
% scope from the variable name.
%    \begin{macrocode}
\cs_new_nopar:Nn \keys_variable_set:NN {
  \cs_if_exist:cF {
    \keys_variable_get_type:N #2 _
    \keys_variable_get_scope:N #2 set:N #1
  } {
    \msg_error:nnxx { keys } { no~set~function } {
      \exp_not:c {
        \keys_variable_get_type:N #2 _
        \keys_variable_get_scope:N #2 set:N #1
      }
    } {#2}
  }
  \cs_if_exist:NF #2 {
    \use:c { \keys_variable_get_type:N #2 _new:N } #2
  }
  \keys_cmd_set:nNx { \l_keys_path_tl } 1 {
    \exp_not:c { 
      \keys_variable_get_type:N #2 _
      \keys_variable_get_scope:N #2 set:N #1 
    } \exp_not:N #2 {##1}
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsubsection{Properties}
%
%\begin{macro}{.choice:}
% Making a choice is handled internally, as it is also needed by
% \texttt{.generate_choices:nn}.
%    \begin{macrocode}
\keys_property_new:nn { .choice: } {
  \keys_choice_make:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{.code:n}
%\begin{macro}{.code:x}
%\begin{macro}{.code:Nn}
%\begin{macro}{.code:Nx}
% Creating code is simply a case of passing through to the underlying
% \texttt{set} function.
%    \begin{macrocode}
\keys_property_new:nn { .code:n } {
  \keys_cmd_set:nNn { \l_keys_path_tl } 1 {#1}
}
\keys_property_new:nn { .code:Nn } {
  \keys_cmd_set:nNn { \l_keys_path_tl } #1 {#2}
}
\keys_property_new:nn { .code:x } {
  \keys_cmd_set:nNx { \l_keys_path_tl } 1 {#1}
}
\keys_property_new:nn { .code:Nx } {
  \keys_cmd_set:nNx { \l_keys_path_tl } #1 {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.default:n}
%\begin{macro}{.default:V}
% Expansion is left to the internal functions.
%    \begin{macrocode}
\keys_property_new:nn { .default:n } {
  \keys_default_set:n  {#1} 
}
\keys_property_new:nn { .default:V } {
  \keys_default_set:V #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.generate_choices:nn}
%\begin{macro}{.generate_choices:nx}
% Making choices is expansion-dependent.
%    \begin{macrocode}
\keys_property_new:nn { .generate_choices:nn } {
  \keys_choices_generate:nx {#1} { \exp_not:n {#2} }
}
\keys_property_new:nn { .generate_choices:nx } {
  \keys_choices_generate:nx {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.set:N}
%\begin{macro}{.set_x:N}
% Setting a variable is very easy: just pass the data along.
%    \begin{macrocode}
\keys_property_new:nn { .set:N } {
  \keys_variable_set:NN n #1
}
\keys_property_new:nn { .set_x:N } {
  \keys_variable_set:NN x #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.set_bool:N}
%\begin{macro}{.set_bool_inverse:N}
% One function for each of these, but this keeps the key functions
% themselves  short.
%    \begin{macrocode}
\keys_property_new:nn { .set_bool:N } {
  \keys_bool_set:N #1
}
\keys_property_new:nn { .set_bool_inverse:N } {
  \keys_bool_set_inverse:N #1
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{.value_forbidden:}
%\begin{macro}{.value_required:}
% These are very similar, so both call the same function.
%    \begin{macrocode}
\keys_property_new:nn { .value_forbidden: } {
  \keys_value_requirement:n { forbidden }
}
\keys_property_new:nn { .value_required: } {
  \keys_value_requirement:n { required } 
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Messages}
%
% For when the package needs to complain.
%    \begin{macrocode}
\msg_new:nnn { keys } { choice~unknown } {%
  Choice `#2' unknown for key `#1':\\%
  the key is being ignored.%
}
\msg_new:nnn { keys } { key~unknown } {%
  The key `#1' is unknown and is being ignored.%
}
\msg_new:nnn { keys } { key~value~forbidden }{%
  The key `#1' cannot taken a value:\\%
  the given input `#2' is being ignored.%
}
\msg_new:nnn { keys } { key~value~required } {%
  The key `#1' requires a value\\%
  and is being ignored.%
}
\msg_new:nnn { keys } { no~property } {%
  No property given in definition of key `#1'.%
}
\msg_new:nnnn { keys } { no~set~function } {%
  There is no function #1\\%
  for setting variable \exp_not:N #2.%
}{%
  keys3 can only `set' variables which have a function\\%
  \exp_not:N \<var>_(g)set:Nn, or in some cases 
  \exp_not:N \<var>_(g)set:Nx.\\%
  You have asked to `set' some other kind of variable.%
  
}
\msg_new:nnn { keys } { property~unknown } {%
  The key property `#1' is unknown.%
}
\msg_new:nnn { keys } { property~value~required } {%
  The property `#1' requires a value\\%
  and is being ignored.%
}
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%\end{implementation}