%\iffalse
% !TEX encoding = ISO-8859-1
% !TEX program  = pdflatex
%% File: keys3.dtx Copyright (C) 2008-2009 Joseph Wright
%%
%% It may be distributed and/or modified under the conditions of the
%% LaTeX Project Public License (LPPL), either version 1.3c of this
%% license or (at your option) any later version.  The latest version
%% of this license is in the file
%%
%%    http://www.latex-project.org/lppl.txt
%%
%% -----------------------------------------------------------------------
%<*driver|package>
\RequirePackage{l3names}
%</driver|package>
%\fi
\GetIdInfo$Id$
  {Key management for LaTeX3}
%\iffalse
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\begin{document}
\DocInput{\filename.\filenameext}
\end{document}
%</driver>
% \fi
%
% \title{The \textsf{keys3} package^^A
%   \thanks{This file has version number \fileversion, last
%     revised \filedate.}\\
% Key management for \LaTeX3}
% \author{Joseph Wright^^A
%   \thanks{E-mail: joseph.wright@morningstar2.co.uk}}
% \date{\filedate}
% \maketitle
%
%\section{Key management}
%
% The key--value method is a popular system for creating large numbers
% of settings for controlling macro or package behaviour.  For the
% user, the system normally results in input of the form
%\begin{verbatim}
%  \PackageControlMacro{
%    key     = value,
%    key two = value two
%  }
%\end{verbatim}
% or
%\begin{verbatim}
%  \PackageMacro[
%    key     = value,
%    key two = value two
%  ]{argument}.
%\end{verbatim}
% For the programmer, the original \textsf{keyval} package gives only
% the most basic interface for this work.  All key macros have to be
% created one at a time, and as a result the \textsf{kvoptions} and
% \textsf{xkeyval} packages have been written to extend the ease of
% creating keys.  However, the underlying model is rather inflexible.
%
% As an alternative, \textsf{pgfkeys} from the \textsf{pgf}/Ti\emph{k}z
% bundle uses a ``file-like'' model for keys. In this model, each key
% has one or more functions attached to define its action.  In
% \textsf{pgfkeys} terminology, these are key \emph{handlers}. Keys can
% be created and used using a unified interface:
%\begin{verbatim}
%  \pgfkeys{
%    /path/key/.handler = code,
%    /path/key          = value
%  }
%\end{verbatim}
%
% The \textsf{keys3} package is aimed at creating a high-level
% programmers interface for key--value controls in \LaTeX3. Key
% creation and control follows the \textsf{pgfkeys} closely, although
% changes have been made to adhere to the new coding ideas of \LaTeX3,
% and new functions have been added.  The \textsf{keys3} package is
% \emph{not} a simple translation of \textsf{pgfkeys} to the new syntax.
% In package internals have been written from the ground up, to better
% enforce variable typing and to act in a know manner under failing
% circumstances.
%
% In the \textsf{keys3} model, each key belongs to a module,
% which may have one or more subdivisions. Each key then has
% one or more properties which define how the key acts. The idea
% of a single function for all key control is retained:
%\begin{verbatim}
%  \keys_manage:n{
%    /module/key/.property     = code,
%    /module/sub/key/.property = more code,
%    /module/key               = value
%  }
%\end{verbatim}
% The combination of all \m{module} parts up to the \m{key} is referred
% to as the \emph{path} of the key.
%
%\subsection{Creating, retrieving and setting keys}
%
% The main interface for key management is the the \cs{keys_manage:n}
% macro.  This can be used to create, retrieve and set keys, and is
% therefore the preferred interface for the package.
%
% \begin{function}{%
%   \keys_manage:n|
%   \keys_manage_quick:n}
%   \begin{syntax}
%     "\keys_manage:n" \Arg{keyval list}
%   \end{syntax}
%   The main key management function, which parses over the <keyval
%   list> and processes each key. The standard version removes leading
%   and trailing spaces and checks catcodes for ungrouped ``|,|'' and
%   ``|=|''. The |_quick| version omits these tests for speed, and is
%   therefore more suited to creating keys inside code blocks.
% \end{function}
%
% \begin{function}{%
%   \keys_manage:nn|
%   \keys_manage_quick:nn}
%   \begin{syntax}
%     "\keys_manage:nn" \Arg{path} \Arg{keyval list}
%   \end{syntax}
%   Versions of the above which include a <path> as an argument. These
%   are faster versions of the |:n| macros when setting lots of keys
%   separately and with known paths.
% \end{function}
%
% Setting up and altering keys is carried out using one or more
% properties (in \textsf{pgfkeys}, these are called handlers). In all
% cases, \m{key} may be a full-qualified key with a path, or a partial
% key to which the default path will be added. Notice that when a
% single argument is required, the braces around the argument may be
% omitted without any error arising.
%
%\subsection{Implementation}
%
% The usual preliminaries.  The key--value parsing itself is handled by
% \textsf{l3keyval}, which does the very low-level stuff so there is no
% need to worry here.
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
\RequirePackage{l3keyval,l3messages,l3clist}
%    \end{macrocode}
%
%\subsubsection{Variables and contrasts}
%
%\begin{macro}{\c_keys_cs_prefix_tlp}
% First, the small number of constants needed are created. A prefix is
% used to keep all of the actual key macros in one place.
%    \begin{macrocode}
\tlp_new:Nn \c_keys_cs_prefix_tlp { keys-root }
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\c_keys_root_tlp}
% The key root should have a clear name; like all of the key macros,
% this does not include the prefix.
%    \begin{macrocode}
\tlp_new:Nn \c_keys_root_tlp {/}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\c_keys_errors_path_tlp}
%\begin{macro}{\c_keys_properties_path_tlp}
%\begin{macro}{\c_keys_utilities_path_tlp}
% The locations of all of the keys used by \textsf{keys3} itself.
%    \begin{macrocode}
\tlp_new:Nn \c_keys_errors_path_tlp     { /keys/errors }
\tlp_new:Nn \c_keys_properties_path_tlp { /keys/properties }
\tlp_new:Nn \c_keys_utilities_path_tlp  { /keys }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_keys_current_path_tlp}
%\begin{macro}{\l_keys_default_path_tlp}
%\begin{macro}{\l_keys_choice_path_tlp}
% The current and default paths can be stored as tlps. The default path
% is then initialised as the key root.
%    \begin{macrocode}
\tlp_new:N \l_keys_current_path_tlp
\tlp_new:N \l_keys_default_path_tlp
\tlp_set_eq:NN \l_keys_default_path_tlp \c_keys_root_tlp
\tlp_new:N \l_keys_choice_path_tlp
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\l_keys_current_key_full_tlp}
%\begin{macro}{\l_keys_current_key_name_tlp}
% The current key name and the fully-qualified key are stored.
%    \begin{macrocode}
\tlp_new:N \l_keys_current_key_full_tlp
\tlp_new:N \l_keys_current_default_tlp
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\l_keys_current_value_toks}
% The current value is stored in a token register.
%    \begin{macrocode}
\toks_new:N \l_keys_current_value_toks
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\l_keys_current_module_tlp}
% The module name of the current module is stored here.
%    \begin{macrocode}
\tlp_new:N \l_keys_current_module_tlp
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\l_keys_current_choice_tlp}
%\begin{macro}{\l_keys_current_choice_int}
% Multiple choices need some storage.
%    \begin{macrocode}
\tlp_new:N \l_keys_current_choice_tlp
\int_new:N \l_keys_current_choice_int
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\l_keys_no_value_bool}
% To indicate that no value has been given.
%    \begin{macrocode}
\bool_new:N \l_keys_no_value_bool
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\q_keys_stop}
% A private quark is needed.
%    \begin{macrocode}
\quark_new:N \q_keys_stop
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\l_keys_success_bool}
% A switch for trying keys.
%    \begin{macrocode}
\bool_new:N \l_keys_success_bool
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\l_keys_tmpa_tlp}
% A scratch area.
%    \begin{macrocode}
\tlp_new:N \l_keys_tmpa_tlp
%    \end{macrocode}
%\end{macro}
%
%\subsection{Functions}
%
%\begin{macro}{\keys_manage:n}
%\begin{macro}{\keys_manage_quick:n}
%\begin{macro}{\keys_manage_internal:n}
%\begin{macro}[aux]{\keys_manage_aux:nn}
%\begin{macro}[aux]{\keys_manage_aux:Vn}
% The main key management macros both call the auxiliary function after
% setting up the parser.  The expansion trick means a literal path is
% sent to the later function, and so the default path can be redefined.
%    \begin{macrocode}
\cs_new:NNn \keys_manage:n 1 {
  \cs_set_eq:NN \keys_parse:n \KV_parse_space_removal_sanitize:n
  \tlp_clear:N \l_keys_current_module_tlp
  \keys_manage_internal:n {#1}
}
\cs_new:NNn \keys_manage_quick:n 1 {
  \let:NN \keys_parse:n \KV_parse_no_space_removal_no_sanitize:n
  \tlp_clear:N \l_keys_current_module_tlp
  \keys_manage_internal:n {#1}
}
\cs_new:NNn \keys_manage_internal:n 1 {
  \keys_manage_aux:Vn \l_keys_default_path_tlp {#1}
}
\cs_new:NNn \keys_manage_aux:nn 2 {
  \tlp_set_eq:NN \l_keys_default_path_tlp \c_keys_root_tlp
  \keys_parse_list:n {#2}
  \tlp_set:Nn \l_keys_default_path_tlp {#1}
}
\exp_def_form:nnn { keys_manage_aux } { nn } { Vn }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_manage:nn}
%\begin{macro}{\keys_manage_quick:nn}
%\begin{macro}[aux]{\keys_manage_aux:nnn}
%\begin{macro}[aux]{\keys_manage_aux:Vnn}
% This version uses the same tricks but includes the path as a second
% argument.  When setting lots of keys separately, this is a little
% faster than the key-based method.
%    \begin{macrocode}
\cs_new:NNn \keys_manage:nn 2 {
  \let:NN \keys_parse:n \KV_parse_space_removal_sanitize:n
  \keys_manage_aux:Vnn \l_keys_default_path_tlp {#1} {#2}
}
\cs_new:NNn \keys_manage_quick:nn 2 {
  \let:NN \keys_parse:n \KV_parse_space_no_removal_no_sanitize:n
  \keys_manage_aux:Vnn \l_keys_default_path_tlp {#1} {#2}
}
\cs_new:NNn \keys_manage_aux:nnn 3 {
  \tlp_set:Nn \l_keys_default_path_tlp {#2}
  \tlp_clear:N \l_keys_current_module_tlp
  \keys_parse_list:n {#3}
  \tlp_set:Nn \l_keys_default_path_tlp {#1}
}
\cs_new:NNn \keys_manage_aux:Vnn 3 {
  \exp_args:NV \keys_manage_aux:nnn #1 {#2} {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_bool_new:n}
% To create a new switch, which will be true (as the existence of the 
% switch is the flag here).
%    \begin{macrocode}
\cs_new:NNn \keys_bool_new:n 1 {
  \bool_new:c { \c_keys_cs_prefix_tlp #1 }
  \bool_set_true:c { \c_keys_cs_prefix_tlp #1 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_clear_properties:n}
% To avoid problem on redefinition, all properties are removed.
%    \begin{macrocode}
\cs_new:NNn \keys_clear_properties:n 1 {
  \keys_undefine:n { #1/._boolean }     
  \keys_undefine:n { #1/._cmd:w }      
  \keys_undefine:n { #1/._default_tlp }  
  \keys_undefine:n { #1/._forbidden_bool } 
  \keys_undefine:n { #1/._required_bool }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_default_add:}
% Copies the default value to the current one if needed.
%    \begin{macrocode}
\cs_new:NNn \keys_default_add: 0 {
  \bool_if:NT \l_keys_no_value_bool {
    \keys_if_really_exist:nT 
      { \l_keys_current_key_full_tlp /._default_tlp } {
      \keys_toks_set:Nn \l_keys_current_value_toks
        { \l_keys_current_key_full_tlp /._default_tlp }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_expand:n}
% A helper for expansion.
%    \begin{macrocode}
\cs_new:NNn \keys_expand:n 1 {
  \keys_parse_list:n { \l_keys_current_path_tlp = #1 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_find_code_full:}
%\begin{macro}{\keys_find_code_name:}
% Two functions to find something to process the key value given. First,
% a search is made for either a command property for the key, or a 
% function for the key itself. If that fails, the generic handlers are 
% used after separating out the key name and key path.
%    \begin{macrocode}
\cs_new:NNn \keys_find_code_full: 0 {
  \keys_if_cmd_really_exist:nTF { \l_keys_current_key_full_tlp } {
    \keys_use_cmd:c { \l_keys_current_key_full_tlp }
  }{
    \keys_if_really_exist:nTF { \l_keys_current_key_full_tlp } {
      \bool_if:NTF \l_keys_no_value_bool {
        \keys_use:n { \l_keys_current_key_full_tlp }
      }{
        \keys_set:nx { \l_keys_current_key_full_tlp }
          { \toks_use:N \l_keys_current_value_toks }
      }
    }{
      \keys_find_code_name:
    }
  }
}
\cs_new:NNn \keys_find_code_name: 0 {
  \keys_separate_path:
  \keys_if_cmd_really_exist:nTF
    { \c_keys_properties_path_tlp / \l_keys_current_key_name_tlp } {
    \keys_use_cmd:c  
      {\c_keys_properties_path_tlp / \l_keys_current_key_name_tlp}
  }{
    \keys_if_cmd_really_exist:nTF 
      { \l_keys_current_path_tlp / unknown } {
      \keys_use_cmd:c { \l_keys_current_path_tlp / unknown }
    }{
      \keys_err_use:n { unknown_key }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}[TF]{\keys_if_cmd_really_exist:n}
% A dedicated check for the |._cmd:w| property key.
%    \begin{macrocode}
\def_long_test_function_new:npn { keys_if_cmd_really_exist:n } #1 {
  \if_cs_exist:w \c_keys_cs_prefix_tlp #1 /._cmd:w \cs_end:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\keys_if_really_exist:n}
% Check if a key exists without adding to the hash table.
%    \begin{macrocode}
\def_long_test_function_new:npn { keys_if_really_exist:n } #1 {
  \if_cs_exist:w \c_keys_cs_prefix_tlp #1 \cs_end:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}[TF]{\keys_if_value:n}
% Used for required and forbidden values.
%    \begin{macrocode}
\def_long_test_function_new:npn { keys_if_value:n } #1 {
  \if_cs_exist:w 
    \c_keys_cs_prefix_tlp \l_keys_current_key_full_tlp /._ #1 _bool 
  \cs_end:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_no_value_elt:n}
%\begin{macro}{\keys_value_elt:nn}
% The two functions passed to \textsf{l3keyval} to actually act on each
% key found.
%    \begin{macrocode}
\cs_new:NNn \keys_no_value_elt:n 1 {
  \bool_set_true:N \l_keys_no_value_bool
  \keys_process_elt:nn {#1} { }
}
\cs_new:NNn \keys_value_elt:nn 2 {
  \bool_set_false:N \l_keys_no_value_bool
  \keys_process_elt:nn {#1} {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_parse:n}
% The macro used to actually process the key--value input is taken from
% \textsf{l3keyval}.  There are two possible options, and so at this
% stage the macro is simply reserved.
%    \begin{macrocode}
\cs_new:NNn \keys_parse:n 1 {\ERROR}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_parse_list:n}
% All of the management macros call this common parser. First, the key
% processing macros are defined, then the appropriate parser is called.
%    \begin{macrocode}
\cs_new:NNn \keys_parse_list:n 1 {
  \let:NN \KV_key_value_elt:nn \keys_value_elt:nn
  \let:NN \KV_key_no_value_elt:n \keys_no_value_elt:n
  \keys_parse:n {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_path_add:N}
%\begin{macro}{\keys_path_add:w}
%\begin{macro}[aux]{\keys_path_add_aux:w}
% The code to check for a path looks for a |/| at the start of the key.
%    \begin{macrocode}
\cs_new:NNn \keys_path_add:N 1 {
  \exp_after:NN \keys_path_add:w #1 \q_stop
}
\cs_new:Npn \keys_path_add:w {
  \exp_after:NN \peek_meaning:NTF \c_keys_root_tlp {
    \use_none_delimit_by_q_stop:w
  }{
    \keys_path_add_aux:w
  }
}
\cs_new:Npn \keys_path_add_aux:w #1 \q_stop {
  \tlp_set:Nx \l_keys_current_key_full_tlp {\l_keys_default_path_tlp #1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_process_elt:nn}
% The key processor starts by storing the given key name and value, and
% adding a path to the former if necessary. There is then potentially a
% need to fill in a default value before checking for required or 
% forbidden values.
%    \begin{macrocode}
\cs_new:NNn \keys_process_elt:nn 2 {
  \tlp_set:Nx \l_keys_current_key_full_tlp {#1}
  \toks_set:Nn \l_keys_current_value_toks {#2}
  \keys_path_add:N \l_keys_current_key_full_tlp
  \keys_default_add:
  \keys_if_value:nTF { required } {
    \bool_if:NT \l_keys_no_value_bool {
      \keys_err_use:n { value_required }
    }
  }{
    \keys_if_value:nTF { forbidden } {
      \bool_if:NF \l_keys_no_value_bool {
        \keys_err_use:n { value_forbidden }
      }
    }{
      \keys_find_code_full:
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_put:nnn}
% To add code to one end of a stored key.
%    \begin{macrocode}
\cs_new:NNn \keys_put:nnn 3 {
  \use:c { tlp_put_#1:cn } { \c_keys_cs_prefix_tlp #2 } {#3}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_separate_path:}
%\begin{macro}{\keys_separate_path:w}
% A simple piece of recursion to find the key name and path.
%    \begin{macrocode}
\cs_new:NNn \keys_separate_path: 0 {
  \tlp_clear:N \l_keys_current_path_tlp
  \exp_after:NN \keys_separate_path:w \l_keys_current_key_full_tlp 
    / \q_stop
}
\cs_new:Npn \keys_separate_path:w / #1 / #2 \q_stop {
  \tlist_if_empty:nTF {#2} {
    \tlp_set:Nn \l_keys_current_key_name_tlp {#1}
  }{
     \tlp_put_right:Nn \l_keys_current_path_tlp { / #1 }
     \keys_separate_path:w /#2 \q_stop
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_set:nn}
%\begin{macro}{\keys_set:nx}
% Direct storage of data in keys.
%    \begin{macrocode}
\cs_new:NNn \keys_set:nn 2 {
  \tlp_set:cn { \c_keys_cs_prefix_tlp #1 } {#2}
}
\cs_new:NNn \keys_set:nx 2 {
  \tlp_set:cx { \c_keys_cs_prefix_tlp #1 } {#2}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\keys_set_eq:nn}
% To alias one key to another.
%    \begin{macrocode}
\cs_new:NNn \keys_set_eq:nn 2 {
  \cs_set_eq:cc { \c_keys_cs_prefix_tlp #1 } 
    { \c_keys_cs_prefix_tlp #2 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_toks_new:nn}
% Creates a new token register and stores the given data in it.
%    \begin{macrocode}
\cs_new:NNn \keys_toks_new:nn 2 {
  \toks_new:c { \c_keys_cs_prefix_tlp #1 }
  \toks_set:cn { \c_keys_cs_prefix_tlp #1 } {#2}
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_toks_set:Nn}
% Sets a toks to the content of a key.
%    \begin{macrocode}
\cs_new:NNn \keys_toks_set:Nn 2 {
  \exp_args:NNv \toks_set:Nn #1 { \c_keys_cs_prefix_tlp #2 }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_undefine:n}
% To remove a key.
%    \begin{macrocode}
\cs_new:NNn \keys_undefine:n 1 {
  \cs_set_eq:cN { \c_keys_cs_prefix_tlp #1 } \c_undefined
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_use:n}
% Use whatever is stored in a key.
%    \begin{macrocode}
\cs_new:NNn \keys_use:n 1 {
  \use:c { \c_keys_cs_prefix_tlp #1 }
}
%    \end{macrocode}
%\end{macro}
%
%------
%
%\begin{macro}{\keys_boolean:nN}
%\begin{macro}{\keys_boolean:nc}
% To allow code-sharing for switch control.
%    \begin{macrocode}
\toks_new:N \l_keys_body_toks
\cs_new:Npn \keys_boolean:nN #1#2 {
  \cs_if_free:NT #1 {\bool_new:N #2}
  \keys_parse_list:n {
    \l_keys_current_path_tlp /.code:n = {
      \cs_if_really_exist:cTF {bool_set_##1:c} {
        \use:c {bool_#1_##1:N} #2
      }{
        \keys_err_use:cw {boolean_expected} \l_keys_current_key_full_tlp
          {\toks_use:N \l_keys_current_value_toks}
      }
    },
    \l_keys_current_path_tlp /.default:n = true
  }
  \keys_set:nn {\l_keys_current_path_tlp /._boolean} {\exp_not:N #2}
}
\cs_new:Npn \keys_boolean:nc #1#2 {
  \keys_module_name:
  \cs_if_free:cT {l_ \l_keys_tmpa_tlp #2_bool} {
    \bool_new:c {l_ \l_keys_tmpa_tlp #2_bool}
  }
  \keys_parse_list:n {
    \l_keys_current_path_tlp /.code:x = {
      \exp_not:N \cs_if_really_exist:cTF {bool_set_##1:N} {
        \exp_not:N \use:c {bool_#1_##1:N}
          \exp_not:d {\use:c {l_ \l_keys_tmpa_tlp #2 _bool}}
      }{
        \exp_not:n {
          \keys_err_use:cw {boolean_expected}
            \l_keys_current_key_full_tlp
            {\toks_use:N \l_keys_current_value_toks}
        }
      }
    },
    \l_keys_current_path_tlp /.default:n = true
  }
  \keys_set:nx {\l_keys_current_path_tlp /._boolean} {
    \exp_not:N \exp_not:N \exp_not:d
      {\use:c {l_ \l_keys_tmpa_tlp #2_bool}}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_choice_create:n}
% The system to create choices is quite simple.
%    \begin{macrocode}
\cs_new:Npn \keys_choice_create:n #1 {
  \int_incr:N \l_keys_current_choice_int
  \keys_parse_list:n {
    \l_keys_choice_path_tlp /#1/.code:x = {
      \exp_not:n {\int_set:Nn \l_keys_current_choice_int}
        {\int_use:N \l_keys_current_choice_int}
      \exp_not:n {\tlp_set:Nn \l_keys_current_choice_tlp} {#1}
      \toks_use:N \l_keys_body_toks
    }
  }
}
%    \end{macrocode}
%\end{macro}

%\begin{macro}{\keys_def_cmd:nn}
%\begin{macro}{\keys_def_cmd:cx}
%\begin{macro}{\keys_def_cmd:nnn}
%\begin{macro}{\keys_def_cmd:nnx}
% Creating the |._cmd:w| keys happens here.
%    \begin{macrocode}
\cs_new:NNn \keys_def_cmd:nn 2 {
  \keys_clear_properties:n {#1}
  \cs_set:cNn { \c_keys_cs_prefix_tlp #1 /._cmd:w } 1 {#2}
}
\cs_new:Npn \keys_def_cmd:cx #1#2 {
  \keys_clear_properties:n {#1}
  \cs_set:cpx {\c_keys_cs_prefix_tlp #1/._cmd:w} ##1 \q_keys_stop {#2}
}
\cs_new:NNn \keys_def_cmd:nNn 3 {
  \keys_clear_properties:n {#1}
  \cs_set:cNn { \c_keys_cs_prefix_tlp #1 /._cmd:w } #2 {#3}
}
\cs_new:Npn \keys_def_cmd:nnx #1#2#3 {
  \keys_clear_properties:n {#1}
  \cs_set:cpx {\c_keys_cs_prefix_tlp #1/._cmd:w} #2 \q_keys_stop {#3}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_module_name:}
% The module name is needed in a few places.
%    \begin{macrocode}
\cs_new:Npn \keys_module_name: {
  \tlp_if_empty:NTF \l_keys_current_module_tlp {
    \tlp_clear:N \l_keys_tmpa_tlp
  }{
    \tlp_set:Nx \l_keys_tmpa_tlp {\l_keys_current_module_tlp _}
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\keys_store:NN}
%\begin{macro}{\keys_store:Nc}
% Generic storage functions.
%    \begin{macrocode}
\cs_new:Npn \keys_store:NN #1#2 {
  \keys_parse_list:n {
    \c_keys_properties_path_tlp /.code:n = {
      #1 #2 {##1}
    }
  }
}
\cs_new:Npn \keys_store:Nc #1#2 {
  \keys_module_name:
  \keys_parse_list:n {
    \c_keys_properties_path_tlp /.code:x = {
      \exp_not:N #1 {l_ \l_keys_tmpa_tlp #2_tlp} {##1}
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_use_cmd:cn}
%\begin{macro}{\keys_use_cmd:c}
% Command keys are stored in a slightly odd fashion, and so this macro
% uses them in a ``safe'' way.
%    \begin{macrocode}
\cs_new:Npn \keys_use_cmd:c #1 {
  \showthe\l_keys_current_value_toks
  \exp_args:Nno \keys_use_cmd:cn {#1}
    {\toks_use:N \l_keys_current_value_toks}
}
\cs_new:Npn \keys_use_cmd:cn #1#2 {
  \bool_if:NTF \l_keys_no_value_bool {
    \keys_use:n {#1/._cmd:w} { }
  }{
    %\tempa{#2}\show\tempa
    %\expandafter\show\csname keys-root/#1/.cmd:w
    \keys_use:n {#1/._cmd:w} {#2}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_try:}
% Trying something without errors.
%    \begin{macrocode}
\cs_new:Npn \keys_try: {
  \keys_if_really_exist:nTF {\l_keys_current_path_tlp /._cmd:w} {
    \bool_if:NT \l_keys_no_value_bool {
      \keys_if_really_exist:nT
        {\l_keys_current_path_tlp /._default_tlp} {
        \keys_toks_set:Nn \l_keys_current_value_toks
          {\l_keys_current_path_tlp /._default_tlp}
      }
    }
    \let:NN \l_keys_current_key_full_tlp \l_keys_current_path_tlp 
    \keys_use_cmd:c {\l_keys_current_path_tlp}
    \bool_set_true:N \l_keys_success_bool
  }{
    \keys_if_really_exist:nTF {\l_keys_current_path_tlp} {
      \bool_if:NTF \l_keys_no_value_bool {
        \keys_use:n {\l_keys_current_path_tlp}
      }{
        \tlp_set:co {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp}
          {\toks_use:N \l_keys_current_value_toks}
      }
      \bool_set_true:N \l_keys_success_bool
    }{
      \bool_set_false:N \l_keys_success_bool
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\keys_err_new:cNnnn}
% To create new error messages, a utility function is handy.
%    \begin{macrocode}
\cs_new:Npn \keys_err_new:cNnnn #1 {
  \tlp_new:cn {l_keys_err_#1_tlp} {#1}
  \exp_args:NNc \err_interrupt_new:NNNnnn \c_keys_err_tlp
    {l_keys_err_#1_tlp}
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\l_keys_err_unknown_key_tlp}
%\begin{macro}{\l_keys_err_value_ignored_tlp}
%\begin{macro}{\l_keys_err_value_required_tlp}
%\begin{macro}{\l_keys_err_def_x_args_tlp}
%\begin{macro}{\l_keys_err_boolean_expected_tlp}
%\begin{macro}{\l_keys_err_not_boolean_tlp}
%\begin{macro}{\l_keys_err_unknown_choice_tlp}
% Text for package error messages is stored in |keys3.err|. The error
% names do not need \cs{keys} at the start as they have to be in the
% file.
%    \begin{macrocode}
\err_file_new:Nn \c_keys_err_tlp {keys3.err}
\keys_err_new:cNnnn {unknown_key} 1
  {The~key~`#1'~is~unknown~and~is~being~ignored}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {value_required} 1
  {The~key~`#1'~requires~a~value~and~is~being~ignored}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {value_forbidden} 1
  {The~key~`#1'~cannot~taken~a~value:~\iow_newline:~\text_put_sp:~
   \text_put_sp:~the~one~given~is~being~ignored}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {def_x_args} 1
  {Key~`#1'~has~multiple~arguments~and~was~expanded:~\iow_newline:~
   \text_put_sp:~\text_put_sp:~adding~code~may~give~incorrect~results}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {boolean_expected} 2
  {Key~`#1'~takes~the~Boolean~values~`true'~and~`false'~\iow_newline:~
   \text_put_sp:~\text_put_sp:~only.~The~given~value~`#2'~is~ignored}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {not_boolean} 1
  {Key~`#1'~is~not~a~Boolean~key:~you~cannot~create~a~complement}
  {\err_help_return_or_X:}
  {}
\keys_err_new:cNnnn {unknown_choice} 2
  {Choice~`#2'~unknown~for~key~`#1':~\iow_newline:~\text_put_sp:~
   \text_put_sp:~the~value~give~is~being~ignored}
  {\err_help_return_or_X:}
  {}
\err_file_close:N \c_keys_err_tlp
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\keys_err_use:cw}
%%\begin{macro}{\keys_err_use:n}
% A second utility to use errors.
%    \begin{macrocode}
\cs_new:Npn \keys_err_use:cw #1 {
  \exp_args:NNc \err_interrupt:NNw \c_keys_err_tlp {l_keys_err_#1_tlp}
}
\cs_new:NNn \keys_err_use:n 1 {
  \exp_args:NNc \err_interrupt:NNw \c_keys_err_tlp {l_keys_err_#1_tlp}
     \l_keys_current_key_full_tlp
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsubsection{Property definitions}
%
% The |.code:n| and |.code:nn| properties have to be defined directly.
%    \begin{macrocode}
\keys_def_cmd:nn { \c_keys_properties_path_tlp /.code:n } {
  \keys_def_cmd:nn { \l_keys_current_path_tlp } {#1}
}
\keys_def_cmd:nNn { \c_keys_properties_path_tlp /.code:nn } 2 {
  \keys_def_cmd:nNn { \l_keys_current_path_tlp } #1 {#2}
}
%    \end{macrocode}
%
% The remaining definitions can all be carried out using the package
% itself. Here, the |_quick| method is used as there is no need to
% worry about spaces or catcodes.
%    \begin{macrocode}
\keys_manage_quick:n {
%    \end{macrocode}
% First, an error is created for unknown keys: this should help to
% prevent any odd internal errors.
%    \begin{macrocode}
  \c_keys_errors_path_tlp /unknown/.code:n = {
    \keys_err_use:cw {unknown_key} \l_keys_current_key_full_tlp
  },
%    \end{macrocode}
% The two |:x| definition methods need to be created.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.code:x/.code:n = {
%    \keys_def_cmd:cx {\l_keys_current_path_tlp} {#1}
%  },
%  \c_keys_properties_path_tlp /.code:nx/.code:nn = {#1#2} {
%    \keys_def_cmd:nnx {\l_keys_current_path_tlp} {#1} {#2}
%  },
%    \end{macrocode}
% Initial and default values can now be created.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.initial:n/.code:n = {
%    \keys_set:nn {\l_keys_current_path_tlp} {#1}
%  },
%  \c_keys_properties_path_tlp /.default:n/.code:n = {
%    \keys_set:nn {\l_keys_current_path_tlp /._default_tlp} {#1}
%  },
%    \end{macrocode}
% Values are either required or forbidden, with the appropriate error
% messages. 
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.value~required:/.code:n = {
%    \keys_bool_new:n {\l_keys_current_path_tlp /._required_bool}
%  },
%  \c_keys_errors_path_tlp /value~required/.code:n = {
%    \keys_err_use:cw {value_required} \l_keys_current_key_full_tlp
%  },
%  \c_keys_properties_path_tlp /.value~forbidden:/.code:n = {
%    \keys_bool_new:n {\l_keys_current_path_tlp /._forbidden_bool}
%  },
%  \c_keys_errors_path_tlp /value~forbidden/.code:n = {
%    \keys_err_use:cw {value_forbidden} \l_keys_current_key_full_tlp
%  },
%    \end{macrocode}
% Being able to change path is pretty useful.
%    \begin{macrocode}
  \c_keys_properties_path_tlp /.cd:/.code:n = {
    \tlp_set:Nx \l_keys_default_path_tlp {\l_keys_current_path_tlp /}
  },
%  \c_keys_properties_path_tlp /.module:/.code:n = {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.code:x = {
%        \exp_not:N \tlp_set:Nx \exp_not:N \l_keys_default_path_tlp
%          {\l_keys_current_path_tlp /}
%      }
%    }
%  },
%    \end{macrocode}
% Pre-built lists of keys can be created for regular use.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.apply~keys:n/.code:n = {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.code:n = {\keys_parse_list:n {#1}}
%    }
%  },
%  \c_keys_properties_path_tlp /.apply~keys:x/.code:n = {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.code:x = {
%        \exp_not:N \keys_parse_list:n {#1}
%      }
%    }
%  },
%  \c_keys_properties_path_tlp /.apply~keys:nn/.code:nn = {#1#2} {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.code:nn = {#1} {\keys_parse_list:n {#2}}
%    }
%  },
%  \c_keys_properties_path_tlp /.apply~keys:nx/.code:nn = {#1#2} {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.code:x =
%        {#1} {\exp_not:N \keys_parse_list:n {#2}}
%    }
%  },
%    \end{macrocode}
% Transfer of data in and out.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.key~to~tlp:N/.code:n = {
%    \tlp_set_eq:Nc #1 {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp}
%  },
%  \c_keys_properties_path_tlp /.key~to~tlp:c/.code:n = {
%    \tlp_set_eq:cc {#1} {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp}
%  },
%  \c_keys_properties_path_tlp /.tlp~to~key:N/.code:n = {
%    \tlp_set_eq:cN {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp} #1
%  },
%  \c_keys_properties_path_tlp /.tlp~to~key:c/.code:n = {
%    \tlp_set_eq:cc {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp} {#1}
%  },
%    \end{macrocode}
% That is all of the lower-level things done.  Now use them to build
% some higher-level functionality.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.store~in~tlp:N/.code:n = {
%    \keys_store:NN \tlp_set:Nn #1
%  },
%  \c_keys_properties_path_tlp /.estore~in~tlp:N/.code:n = {
%    \keys_store:NN \tlp_set:Nx #1
%  },
%  \c_keys_properties_path_tlp /.store~in~tlp:c/.code:n = {
%    \keys_store:Nc \tlp_set:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.estore~in~tlp:c/.code:n = {
%    \keys_store:Nc \tlp_set:cx {#1}
%  },
%  \c_keys_properties_path_tlp /.store~in~int:N/.code:n = {
%    \keys_store:NN \int_set:Nn #1
%  },
%  \c_keys_properties_path_tlp /.store~in~int:c/.code:n = {
%    \keys_store:Nc \int_set:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.store~in~skip:N/.code:n = {
%    \keys_store:NN \skip_set:Nn #1
%  },
%  \c_keys_properties_path_tlp /.store~in~skip:c/.code:n = {
%    \keys_store:Nc \skip_set:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.store~in~toks:N/.code:n = {
%    \keys_store:NN \toks_set:Nn #1
%  },
%  \c_keys_properties_path_tlp /.store~in~toks:c/.code:n = {
%    \keys_store:Nc \toks_set:cn {#1}
%  },
%    \end{macrocode}
% Global versions of all of the above storage properties.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.gstore~in~tlp:N/.code:n = {
%    \keys_store:NN \tlp_gset:Nn #1
%  },
%  \c_keys_properties_path_tlp /.xstore~in~tlp:N/.code:n = {
%    \keys_store:NN \tlp_gset:Nx #1
%  },
%  \c_keys_properties_path_tlp /.gstore~in~tlp:c/.code:n = {
%    \keys_store:Nc \tlp_gset:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.xstore~in~tlp:c/.code:n = {
%    \keys_store:Nc \tlp_gset:cx {#1}
%  },
%  \c_keys_properties_path_tlp /.gstore~in~int:N/.code:n = {
%    \keys_store:NN \int_gset:Nn #1
%  },
%  \c_keys_properties_path_tlp /.gstore~in~int:c/.code:n = {
%    \keys_store:Nc \int_gset:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.gstore~in~skip:N/.code:n = {
%    \keys_store:NN \skip_gset:Nn #1
%  },
%  \c_keys_properties_path_tlp /.gstore~in~skip:c/.code:n = {
%    \keys_store:Nc \skip_gset:cn {#1}
%  },
%  \c_keys_properties_path_tlp /.gstore~in~toks:N/.code:n = {
%    \keys_store:NN \toks_gset:Nn #1
%  },
%  \c_keys_properties_path_tlp /.gstore~in~toks:c/.code:n = {
%    \keys_store:Nc \toks_gset:cn {#1}
%  },
%    \end{macrocode}
% Functions should not be stored in tlps.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.let~to~func:N/.code:n = {
%    \keys_parse_list:n {
%      \c_keys_properties_path_tlp /.code:n = {
%        \let:NN #1 ##1
%      }
%    }
%  },
%  \c_keys_properties_path_tlp /.let~to~func:c/.code:n = {
%    \keys_module_name:
%    \keys_parse_list:n {
%      \c_keys_properties_path_tlp /.code:x = {
%        \exp_not:N \let:cN {\l_keys_tmpa_tlp #1:w} ##1
%      }
%    }
%  },
%    \end{macrocode} 
% Boolean keys are created with a true default.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.boolean:N/.code:n = {
%    \keys_boolean:nN {set} #1
%  },
%  \c_keys_properties_path_tlp /.boolean:c/.code:n = {
%    \keys_boolean:nc {set} {#1}
%  },
%    \end{macrocode}
% Once again global versions.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.gboolean:N/.code:n = {
%    \keys_boolean:nN {gset} #1
%  },
%  \c_keys_properties_path_tlp /.gboolean:c/.code:n = {
%    \keys_boolean:nc {gset} {#1}
%  },
%    \end{macrocode}
% Creating an inverse needs a little work as the logic needs to be
% reversed.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.inverse~key:n/.code:n = {
%    \keys_if_really_exist:nTF {\l_keys_current_path_tlp /._boolean} {
%      \tlp_set_eq:NN \l_keys_tmpa_tlp \l_keys_current_path_tlp
%      \tlp_set_eq:NN \l_keys_current_key_full_tlp \l_keys_current_path_tlp
%      \keys_separate_path:
%      \keys_parse_list:n {
%        \l_keys_current_path_tlp /#1/.code:x = {
%          \exp_not:N \tlist_if_eq:nnTF {true} {##1} {
%            \exp_not:N \bool_set_false:N \keys_use:n
%              {\l_keys_tmpa_tlp /._boolean}
%          }{
%            \exp_not:N \tlist_if_eq:nnTF {false} {##1} {
%              \exp_not:N \bool_set_true:N \keys_use:n
%                {\l_keys_tmpa_tlp /._boolean}
%            }{
%              \exp_not:n {
%                \keys_err_use:cw {boolean_expected}
%                  \l_keys_current_key_full_tlp
%                  {\toks_use:N \l_keys_current_value_toks}
%              }
%            }
%          }
%        },
%        \l_keys_current_path_tlp /#1/.default:n = true
%      }
%    }{
%      \keys_err_use:cw {not_boolean} \l_keys_current_path_tlp
%    }
%  },
%    \end{macrocode}
% Choices are handled in a slightly different way.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.choice:/.code:n = {
%    \keys_manage_internal:n {
%      \l_keys_current_path_tlp /.cd:,
%      .code:n = {
%        \tlp_set:Nn \l_keys_current_choice_tlp {##1}
%        \int_zero:N \l_keys_current_choice_int
%        \exp_args:No \keys_parse_list:n {\l_keys_current_key_full_tlp /##1}
%      },
%      unknown/.code:n = {
%        \keys_err_use:cw {unknown_choice} \l_keys_current_path_tlp
%          {\l_keys_current_key_name_tlp}
%      }
%    }
%  },
%    \end{macrocode}
% Multiple choices can also be created.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.choices:nn/.code:nn = {#1#2} {
%    \tlp_set_eq:NN \l_keys_choice_path_tlp \l_keys_current_path_tlp
%    \toks_set:Nn \l_keys_body_toks {#2}
%    \int_zero:N \l_keys_current_choice_int
%    \clist_map_function:nN {#1} \keys_choice_create:n
%    \keys_manage_internal:n {
%      \l_keys_choice_path_tlp  /.choice:
%    }
%  },
%    \end{macrocode}
% Different names for the same thing.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.equivalent~key:n/.code:n = {
%    \keys_if_really_exist:nT {\l_keys_current_path_tlp /._cmd:w} {
%      \tlp_set_eq:NN \l_keys_current_key_full_tlp \l_keys_current_path_tlp
%      \keys_separate_path:
%      \keys_set_eq:nn {\l_keys_current_path_tlp /#1/._cmd:w}
%        {\l_keys_current_key_full_tlp /._cmd:w}
%    }
%  },
%    \end{macrocode}
% Expansion keys need to be available.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.expand:o/.code:n = {
%    \exp_args:No \keys_expand:n {#1}
%  },
%  \c_keys_properties_path_tlp /.expand:d/.code:n = {
%    \exp_args:NNo \exp_args:No \keys_expand:n {#1}
%  },
%  \c_keys_properties_path_tlp /.expand:x/.code:n = {
%    \exp_args:Nx \keys_expand:n {#1}
%  },
%    \end{macrocode}
% ``Trying'' a key.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.try:n/.code:n = {\keys_try:},
%  \c_keys_properties_path_tlp /.retry:n/.code:n = {
%    \bool_if:NF \l_keys_success_bool {\keys_try:}
%  },
%    \end{macrocode}
%
% Some debugging keys.
%    \begin{macrocode}
%  \c_keys_properties_path_tlp /.show~code:/.code:n = {
%    \cs_show:c {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp /._cmd:w}
%  },
%  \c_keys_properties_path_tlp /.show:/.code:n = {
%    \cs_show:c {\c_keys_cs_prefix_tlp \l_keys_current_path_tlp}
%  },
%    \end{macrocode}
% Keys for programmers.
%    \begin{macrocode}
%  \c_keys_utilities_path_tlp /execute:n/.code:n = {#1},
%  \c_keys_utilities_path_tlp /current~module:n/.store~in~tlp:N =
%    \l_keys_current_module_tlp
}
%</package>
%    \end{macrocode}
%
%\Finale
